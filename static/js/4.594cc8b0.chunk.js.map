{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/graphql-tag/src/index.js","schema/calendar.ts"],"names":["_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","parse","require","normalize","string","replace","trim","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","parseDocument","doc","cacheKey","parsed","kind","Error","stripLoc","removeLocAtThisLevel","docType","prototype","toString","call","map","d","loc","startToken","endToken","key","valueType","keys","hasOwnProperty","ast","astFragmentMap","definitions","i","length","fragmentDefinition","fragmentName","name","sourceKey","source","body","substring","start","end","console","warn","push","processFragments","gql","args","Array","arguments","literals","result","default","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","module","exports","events","id","description","typeDefs","resolvers","Query","Mutation","addEvent","_","event"],"mappings":"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","file":"static/js/4.594cc8b0.chunk.js","sourcesContent":["export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","import gql from \"graphql-tag\";\n\nconst events = [\n  { id: 0, name: \"Shopping\", description: \"Gifts\" },\n  { id: 1, name: \"Vet\", description: \"Dog is sick\" },\n  { id: 2, name: \"Party\", description: \"After months of Covid-19\" },\n];\n\nexport const typeDefs = gql`\n  extend type Query {\n    events: [Event!]\n  }\n\n  extend type Mutation {\n    addEvent(name: String!, description: String): Event!\n  }\n\n  type Event {\n    id: ID!\n    name: String!\n    description: String\n  }\n`;\n\nexport const resolvers = {\n  Query: {\n    events() {\n      return events;\n    },\n  },\n  Mutation: {\n    addEvent(_: never, { name, description }: any) {\n      const event = {\n        id: events.length,\n        name,\n        description,\n      };\n\n      events.push(event);\n\n      return event;\n    },\n  },\n};\n"],"sourceRoot":""}