{"version":3,"sources":["App.tsx","schema-modules-link.ts","apollo.tsx","index.tsx"],"names":["Home","React","lazy","Chats","Calendar","Both","App","useState","page","setPage","onClick","Suspense","fallback","isOperationNode","def","kind","Kind","OPERATION_DEFINITION","onlyUnique","val","i","list","indexOf","client","ApolloClient","cache","InMemoryCache","link","manager","map","schemaBuilder","usedModules","collectRequiredModules","doc","op","definitions","find","selectionSet","selections","field","name","value","str","operation","charAt","toUpperCase","slice","findRootFieldsAndKind","rootFields","operationKind","filter","loadModules","ids","a","Promise","all","mod","modules","mods","sharedModule","shared","concat","toast","schema","typeDefs","concatAST","m","resolvers","buildSchema","fn","hash","compare","memoizedResult","memoizedInput","input","currentHash","memo","sort","join","memoHash","execute","document","variableValues","operationName","modulesToLoad","includes","SchemaModulesManager","ApolloLink","fromPromise","query","variables","createSchemaModulesLink","Query","events","chats","Mutation","addEvent","Subscription","makeExecutableSchema","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.15d13a7a.chunk.js","sourcesContent":["import React from \"react\";\nimport { ToastContainer } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\n\nconst Home = React.lazy(() => import(\"./chunks/home\"));\nconst Chats = React.lazy(() => import(\"./chunks/chats\"));\nconst Calendar = React.lazy(() => import(\"./chunks/calendar\"));\nconst Both = React.lazy(() => import(\"./chunks/chats-and-calendar\"));\n\nfunction App() {\n  const [page, setPage] = React.useState<\n    \"home\" | \"chats\" | \"calendar\" | \"both\"\n  >(\"home\");\n\n  return (\n    <>\n      <div>\n        <button onClick={() => setPage(\"home\")}>Home</button>\n        <button onClick={() => setPage(\"chats\")}>Chats</button>\n        <button onClick={() => setPage(\"calendar\")}>Calendar</button>\n        <button onClick={() => setPage(\"both\")}>\n          Chats and Calendar on one screen\n        </button>\n      </div>\n      <React.Suspense fallback={<div>Loading</div>}>\n        <div>\n          {page === \"chats\" ? (\n            <Chats />\n          ) : page === \"calendar\" ? (\n            <Calendar />\n          ) : page === \"both\" ? (\n            <Both />\n          ) : (\n            <Home />\n          )}\n        </div>\n      </React.Suspense>\n      <ToastContainer />\n    </>\n  );\n}\n\nexport default App;\n","import { toast } from \"react-toastify\";\n\nimport { ApolloLink, fromPromise } from \"apollo-link\";\nimport {\n  OperationDefinitionNode,\n  DefinitionNode,\n  ExecutionArgs,\n  DocumentNode,\n  FieldNode,\n  execute,\n  Kind,\n  ExecutionResult,\n  GraphQLSchema,\n  OperationTypeNode,\n  concatAST,\n} from \"graphql\";\n\ntype OperationType = \"Query\" | \"Mutation\" | \"Subscription\";\n\n/**\n * Represents the exported keywords of a module\n */\ntype SchemaModule = {\n  typeDefs: DocumentNode;\n  resolvers?: {};\n};\n/**\n * A function that loads a module\n */\ntype SchemaModuleLoader = () => Promise<SchemaModule>;\n/**\n * A map between fields of Queries, Mutations or Subscriptions and Schema Modules\n */\nexport type SchemaModuleMap = {\n  modules: SchemaModuleLoader[];\n  sharedModule: SchemaModuleLoader;\n  Query: Record<string, number>;\n  Mutation: Record<string, number>;\n  Subscription: Record<string, number>;\n};\n\nexport type SchemaModuleLinkOptions = {\n  map: SchemaModuleMap;\n  schemaBuilder(input: {\n    typeDefs: DocumentNode;\n    resolvers: any[];\n  }): GraphQLSchema;\n};\n\n/**\n * Creates an ApolloLink that lazy-loads parts of schema, with resolvers and context.\n */\nexport function createSchemaModulesLink({\n  map,\n  schemaBuilder,\n}: SchemaModuleLinkOptions) {\n  const manager = SchemaModulesManager({ map, schemaBuilder });\n\n  return new ApolloLink((op) =>\n    fromPromise(\n      manager.execute({\n        document: op.query,\n        variableValues: op.variables,\n        operationName: op.operationName,\n      })\n    )\n  );\n}\n\n/**\n * Manages Schema Module, orchestrates the lazy-loading, deals with schema building etc\n */\nfunction SchemaModulesManager({ map, schemaBuilder }: SchemaModuleLinkOptions) {\n  let usedModules: number[] = [];\n\n  /**\n   * Collects a list of required modules (based on root-level fields)\n   * and a kind of an operation (Q, M or S)\n   */\n  function collectRequiredModules(doc: DocumentNode): number[] {\n    const [rootFields, operationKind] = findRootFieldsAndKind(doc);\n\n    return rootFields\n      .map((field) => map[operationKind][field])\n      .filter(onlyUnique);\n  }\n\n  /**\n   * Loads all requested modules by their id + shared module\n   */\n  async function loadModules(ids: number[]) {\n    const mods = await Promise.all(ids.map((mod) => map.modules[mod]()));\n    const shared = await map.sharedModule();\n\n    return mods.concat([shared]);\n  }\n\n  /**\n   * Builds GraphQLSchema object based on a list of module ids\n   * Does the memoization internally to avoid unnecessary computations\n   */\n  async function _buildSchema(ids: number[]) {\n    const modules = await loadModules(ids);\n\n    // saves a list of used modules including those requested by operation\n    usedModules = usedModules.concat(ids).filter(onlyUnique);\n\n    toast(\"Built schema\");\n\n    const schema = schemaBuilder({\n      typeDefs: concatAST(modules.map((m) => m.typeDefs)),\n      resolvers: modules.map((m) => m.resolvers || {}),\n    });\n\n    return schema;\n  }\n\n  function hash(list: number[]) {\n    return list.slice().sort().join(\"-\");\n  }\n\n  function compare(currentHash: string, memoHash: string) {\n    return memoHash === currentHash;\n  }\n\n  const buildSchema = memo(_buildSchema, hash, compare);\n\n  return {\n    async execute({\n      document,\n      variableValues,\n      operationName,\n    }: Pick<\n      ExecutionArgs,\n      \"document\" | \"variableValues\" | \"operationName\"\n    >): Promise<ExecutionResult> {\n      const modules = collectRequiredModules(document);\n      const modulesToLoad = modules.filter((mod) => !usedModules.includes(mod));\n\n      return execute({\n        schema: await buildSchema(modulesToLoad.concat(usedModules)),\n        document,\n        variableValues,\n        operationName,\n      });\n    },\n  };\n}\n\nfunction findRootFieldsAndKind(doc: DocumentNode): [string[], OperationType] {\n  const op = doc.definitions.find(isOperationNode)!;\n\n  const rootFields = op.selectionSet.selections.map(\n    (field) => (field as FieldNode).name.value\n  );\n\n  return [rootFields, capitalizeFirst(op.operation)];\n}\n\nfunction isOperationNode(def: DefinitionNode): def is OperationDefinitionNode {\n  return def.kind === Kind.OPERATION_DEFINITION;\n}\n\nfunction capitalizeFirst(str: OperationTypeNode): OperationType {\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as OperationType;\n}\n\nfunction onlyUnique<T>(val: T, i: number, list: T[]) {\n  return list.indexOf(val) === i;\n}\n\nfunction memo<A, R, H>(\n  fn: (input: A) => R,\n  hash: (input: A) => H,\n  compare: (current: H, previous: H) => boolean\n) {\n  let memoizedResult: R;\n  let memoizedInput: H;\n\n  return (input: A): R => {\n    const currentHash = hash(input);\n    if (compare(currentHash, memoizedInput)) {\n      toast(\"Used memoized schema\");\n      return memoizedResult;\n    }\n\n    memoizedResult = fn(input);\n    memoizedInput = currentHash;\n\n    return memoizedResult;\n  };\n}\n","import { ApolloClient } from \"apollo-client\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\nimport { makeExecutableSchema } from \"@graphql-tools/schema\";\nimport { createSchemaModulesLink } from \"./schema-modules-link\";\n\nexport const client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: createSchemaModulesLink({\n    // this map is going to be auto-generated\n    map:\n      // no need to write it manually\n      {\n        modules: [\n          () => import(\"./schema/calendar\"),\n          () => import(\"./schema/chats\"),\n        ],\n        sharedModule: () => import(\"./schema/shared\"),\n        Query: {\n          events: 0,\n          chats: 1,\n        },\n        Mutation: {\n          addEvent: 0,\n        },\n        Subscription: {},\n      },\n    schemaBuilder: makeExecutableSchema,\n  }),\n});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { ApolloProvider } from \"react-apollo\";\nimport App from \"./App\";\nimport { client } from \"./apollo\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ApolloProvider client={client}>\n      <App />\n    </ApolloProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}